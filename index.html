<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>SignAi ‚Äî HOP 7.0 Alpha (BIO-ID + Vault + Content Origin)</title>
<style>
:root{
  --bg:#050a14;--panel:#0f1c38;--panel2:#0b152b;--glass:rgba(14,24,48,.72);
  --text:#eaf2ff;--muted:#a6b7ce;--border:#1a2947;
  --accent:#22b7ff;--accent2:#22e0d8;--ok:#16a34a;--bad:#ef4444;--expired:#3b82f6
}
*{box-sizing:border-box}html,body{height:100%}
body{
  margin:0;
  background:radial-gradient(80% 60% at 50% 0%,#081127 0%,#050a14 60%,#040813 100%);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--text)
}
.wrap{max-width:1040px;margin:0 auto;padding:16px 18px}
/* HEADER */
header{
  position:sticky;top:0;
  background:rgba(5,10,20,.9);
  backdrop-filter:blur(16px);
  border-bottom:1px solid var(--border);
  z-index:10;
}
.header-inner{
  display:flex;align-items:center;justify-content:space-between;
  gap:12px;padding:10px 2px;
}
.brand{display:flex;align-items:center;gap:12px}
.brand-logo{
  height:44px;width:44px;border-radius:10px;
  border:1px solid var(--border);
  background:radial-gradient(circle at 30% 0%,#22b7ff22,transparent 60%),linear-gradient(180deg,#0a1530,#071024);
  display:grid;place-items:center;overflow:hidden;
}
.brand-logo img{width:100%;height:100%;object-fit:cover}
.brand h1{
  margin:0;font-size:18px;font-weight:800;letter-spacing:.2px
}
.brand .tag{
  margin:0;font-size:12px;color:var(--muted)
}

/* TOP NAV */
.nav{
  display:flex;gap:6px;flex-wrap:wrap;justify-content:center;
  padding:4px 6px;
  border-radius:999px;
  background:radial-gradient(circle at 0 0,#22b7ff11,transparent 60%);
}
.tab{
  border-radius:999px;border:1px solid var(--border);
  padding:7px 12px;font-weight:700;
  cursor:pointer;background:var(--panel2);color:var(--text);
  transition:filter .2s,background .2s,transform .12s,border-color .2s;
  font-size:13px;display:flex;align-items:center;gap:6px;
}
.tab span.emoji{font-size:14px}
.tab:hover{filter:brightness(1.08);transform:translateY(-1px)}
.tab.active{
  background:linear-gradient(120deg,var(--accent),var(--accent2));
  color:#062630;border-color:transparent;
  box-shadow:0 8px 25px rgba(34,183,255,.25);
}

/* STEPPER & PAGER */
.stepper{
  display:flex;gap:8px;justify-content:center;
  flex-wrap:wrap;margin:10px 0 6px
}
.step{
  display:flex;gap:6px;align-items:center;
  border:1px solid #26406c;background:#0b152b;
  color:#bcd0ea;border-radius:999px;
  padding:6px 11px;font-weight:700;font-size:12px
}
.step.active{
  background:linear-gradient(90deg,var(--accent),var(--accent2));
  color:#062630;border-color:transparent
}
.pager{
  display:flex;justify-content:space-between;
  align-items:center;gap:12px;margin-top:8px
}
.pill{
  border:1px solid var(--border);background:#0b152b;color:#cfe2ff;
  border-radius:999px;padding:8px 12px;font-weight:700;
  cursor:pointer;font-size:13px
}
.pill:disabled{opacity:.4;cursor:not-allowed}

/* CARDS */
.card{
  background:linear-gradient(180deg,var(--glass),transparent),var(--panel);
  border:1px solid var(--border);border-radius:14px;
  padding:16px;margin:12px 0
}
.helper{font-size:12.8px;color:var(--muted)}
.label{font-size:13px;color:var(--muted);margin:6px 0;font-weight:600}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}

/* DASHBOARD */
.dashboard-grid{
  display:grid;
  grid-template-columns:2.2fr 1.8fr;
  gap:12px;
}
@media(max-width:900px){
  .dashboard-grid{
    grid-template-columns:1fr;
  }
}
.creator-dashboard{
  display:flex;
  flex-direction:column;
  gap:10px;
}
.creator-dashboard-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
}
.creator-dashboard-title{
  font-size:14px;
  font-weight:800;
}
.creator-dashboard-pillrow{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  margin-top:4px;
}
.cd-pill{
  font-size:11px;
  padding:4px 9px;
  border-radius:999px;
  border:1px solid #1f2a3f;
  background:#050b18;
  color:#cdd9f7;
}
.cd-pill span{
  opacity:.7;
}
.creator-dashboard-grid{
  display:grid;
  grid-template-columns:repeat(2,minmax(0,1fr));
  gap:8px;
  margin-top:6px;
}
@media (max-width:720px){
  .creator-dashboard-grid{
    grid-template-columns:minmax(0,1fr);
  }
}
.creator-stat-label{
  font-size:11px;
  color:#8ea2c6;
  text-transform:uppercase;
  letter-spacing:.06em;
}
.creator-stat-value{
  font-size:12.5px;
  font-weight:700;
  color:#e5f1ff;
}

/* Latest badge / verification list */
.badge-summary{
  font-size:12.8px;
  color:#d1e4ff;
  line-height:1.45;
}
.badge-summary code{
  font-family:ui-monospace,Consolas,monospace;
  font-size:11.6px;
}
.table-mini{
  width:100%;
  border-collapse:collapse;
  font-size:12px;
  margin-top:4px;
}
.table-mini th,
.table-mini td{
  padding:4px 6px;
  border-bottom:1px solid #1b2742;
  text-align:left;
}
.table-mini th{
  color:#9fb0c4;
  font-weight:600;
}
.table-mini tr:last-child td{
  border-bottom:none;
}
.status-pill{
  display:inline-block;
  padding:2px 7px;
  border-radius:999px;
  font-size:11px;
  font-weight:700;
}
.status-ok{
  background:rgba(22,163,74,.18);
  color:#bbf7d0;
  border:1px solid rgba(22,163,74,.6);
}
.status-fail{
  background:rgba(239,68,68,.16);
  color:#fecaca;
  border:1px solid rgba(239,68,68,.7);
}
.status-expired{
  background:rgba(59,130,246,.16);
  color:#bfdbfe;
  border:1px solid rgba(59,130,246,.8);
}

/* INPUTS */
.input,textarea{
  width:100%;background:var(--panel2);
  border:1px solid var(--border);color:var(--text);
  padding:10px;border-radius:10px;font-size:14px
}
textarea{min-height:110px;resize:vertical}
pre{
  background:var(--panel2);border:1px solid var(--border);
  border-radius:10px;padding:10px;overflow:auto;
  white-space:pre-wrap;word-wrap:break-word;
  font-family:ui-monospace,Consolas,Menlo,monospace;
  font-size:12.5px;line-height:1.4
}

/* BUTTONS */
.btn{
  border-radius:10px;border:1px solid var(--border);
  padding:10px 12px;font-weight:800;
  cursor:pointer;font-size:13px
}
.btn.primary{
  background:linear-gradient(90deg,var(--accent),var(--accent2));
  color:#062630;border:0;
  box-shadow:0 8px 24px rgba(34,183,255,.18)
}

/* BADGE PREVIEW */
.resultBox{
  background:var(--panel2);border:2px solid var(--border);
  border-radius:12px;padding:12px;margin-top:8px;
  transition:box-shadow .2s,border-color .2s;
  text-align:left
}
.resultBox.ok{border-color:var(--ok);box-shadow:0 0 0 3px rgba(22,163,74,.16)}
.resultBox.bad{border-color:var(--bad);box-shadow:0 0 0 3px rgba(239,68,68,.16)}
.resultBox.expired{border-color:var(--expired);box-shadow:0 0 0 3px rgba(59,130,246,.16)}
.badgeFrame{display:flex;justify-content:center;align-items:center;min-height:200px}
.badgeClickableHint{font-size:11px;color:#9fb0c4;text-align:center;margin-top:6px;opacity:.8}
#b_preview.clickable{cursor:pointer;outline:2px solid rgba(34,183,255,.35);outline-offset:2px}

/* VERIFY TEXT */
.bigStatus{font-weight:800;margin-bottom:6px}
.subStatus{font-size:12.6px;color:#a2b6d1}

/* IMAGE PREVIEW (TRACE TAB) */
#c_thumb{
  display:block;max-width:260px;
  border:1px solid var(--border);border-radius:10px;margin-top:8px
}
.hide{display:none}

/* FOOTER */
footer{
  margin:18px 0 28px;color:var(--muted);
  font-size:12.5px;text-align:center
}

/* SIGNAL BREAKDOWN LIST */
.check-list{
  margin-top:10px;
  border-top:1px solid #1a2947;
  padding-top:10px;
  font-size:12.6px;
}
.check-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  margin:3px 0;
}
.check-label{color:#a2b6d1}
.check-pill{
  min-width:42px;
  text-align:center;
  padding:2px 8px;
  border-radius:999px;
  font-size:11px;
  font-weight:700;
}
.check-ok{
  color:#bbf7d0;
  background:rgba(22,163,74,.18);
  border:1px solid rgba(22,163,74,.6);
}
.check-fail{
  color:#fecaca;
  background:rgba(239,68,68,.16);
  border:1px solid rgba(239,68,68,.7);
}
.check-na{
  color:#e5e7eb;
  background:rgba(148,163,184,.16);
  border:1px solid rgba(148,163,184,.6);
}
.check-legend{
  margin-top:8px;
  font-size:12px;
  color:#94a3b8;
}
</style>
</head>
<body>
<header>
  <div class="wrap header-inner">
    <div class="brand">
      <div class="brand-logo">
        <img id="signai_logo" src="1.png" alt="SignAi">
      </div>
      <div>
        <h1>SignAi</h1>
        <p class="tag">Alpha 1.0</p>
      </div>
    </div>
    <nav class="nav">
      <button class="tab active" id="tb_dashboard" onclick="switchTab('dashboard', this)">
        <span class="emoji">üè†</span><span>Dashboard</span>
      </button>
      <button class="tab" id="tb_signai" onclick="switchTab('signai', this)">
        <span class="emoji">üß¨</span><span>Identity</span>
      </button>
      <button class="tab" id="tb_trace" onclick="switchTab('trace', this)">
        <span class="emoji">üîó</span><span>TRACE</span>
      </button>
      <button class="tab" id="tb_verify" onclick="switchTab('verify', this)">
        <span class="emoji">üîç</span><span>Verify</span>
      </button>
      <button class="tab" id="tb_vault" onclick="switchTab('vault', this)">
        <span class="emoji">üîê</span><span>Vault</span>
      </button>
      <button class="tab" id="tb_about" onclick="switchTab('about', this)">
        <span class="emoji">üìò</span><span>About</span>
      </button>
    </nav>
  </div>
</header>

<div class="wrap">
  <!-- STEPPER -->
  <div class="stepper">
    <div class="step" id="st1">0. Vault</div>
    <div class="step" id="st2">1. Keys</div>
    <div class="step" id="st3">2. Mindprint</div>
    <div class="step" id="st4">3. Content Origin</div>
    <div class="step" id="st5">4. TRACE & Verify</div>
  </div>

  <!-- PAGER -->
  <div class="pager">
    <button id="btnPrev" class="pill" onclick="goPrev()">‚Üê Previous</button>
    <div></div>
    <button id="btnNext" class="pill" onclick="goNext()">Next ‚Üí</button>
  </div>

  <!-- TAB: DASHBOARD -->
  <section id="tab-dashboard">
    <div class="dashboard-grid">
      <!-- Left: Creator overview -->
      <div class="card creator-dashboard">
        <div class="creator-dashboard-header">
          <div class="creator-dashboard-title">Creator dashboard</div>
          <div class="helper">Local BIO-ID ¬∑ No cloud ¬∑ TRACE ready</div>
        </div>
        <div class="creator-dashboard-pillrow">
          <div class="cd-pill"><span>Flow:</span> Vault ‚Üí Keys ‚Üí Mindprint ‚Üí TRACE ‚Üí Verify</div>
          <div class="cd-pill"><span>Mode:</span> Offline ¬∑ WebCrypto Ed25519</div>
          <div class="cd-pill"><span>Assets:</span> Text + optional image</div>
        </div>
        <div class="creator-dashboard-grid">
          <div>
            <div class="creator-stat-label">Creator ID</div>
            <div class="creator-stat-value" id="cd_creator_id">(no key yet)</div>
          </div>
          <div>
            <div class="creator-stat-label">Vault status</div>
            <div class="creator-stat-value" id="cd_vault_status">Not initialized</div>
          </div>
          <div>
            <div class="creator-stat-label">Mindprint</div>
            <div class="creator-stat-value" id="cd_mindprint">Not registered</div>
          </div>
          <div>
            <div class="creator-stat-label">Last content origin</div>
            <div class="creator-stat-value" id="cd_origin_status">No analysis yet</div>
          </div>
        </div>
      </div>
      <!-- Right: Quick actions -->
      <div class="card">
        <div class="label"><b>Quick actions</b></div>
        <div class="row" style="margin-bottom:8px">
          <button class="btn primary" onclick="switchTab('trace', document.getElementById('tb_trace'))">
            Create TRACE badge
          </button>
          <button class="btn" onclick="switchTab('verify', document.getElementById('tb_verify'))">
            Verify a badge
          </button>
        </div>
        <div class="row">
          <button class="btn" onclick="switchTab('vault', document.getElementById('tb_vault'))">
            Open Vault
          </button>
          <button class="btn" onclick="switchTab('signai', document.getElementById('tb_signai'))">
            Keys & Mindprint
          </button>
        </div>
        <div class="helper" style="margin-top:10px">
          Dashboard is just a shortcut. All real work still happens in each tab.
        </div>
      </div>
    </div>

    <!-- Latest badge -->
    <div class="card">
      <div class="label"><b>Latest badge</b></div>
      <div id="dash_latest_badge" class="badge-summary">
        No badge created yet. Go to TRACE and create your first badge.
      </div>
    </div>

    <!-- Recent verifications -->
    <div class="card">
      <div class="label"><b>Recent verifications</b></div>
      <div id="dash_verifications" class="helper">
        No verifications yet. Verify a badge to see it here.
      </div>
    </div>
  </section>

  <!-- TAB: SIGNAI / IDENTITY -->
  <section id="tab-signai" class="hide">
    <div class="card">
      <div class="label"><b>Step 0 ‚Äì Unlock your BIO-ID Vault (recommended)</b></div>
      <div class="helper">
        For maximum safety, set and unlock your Vault password first (see Vault tab).
        You can‚Äôt create keys unless the Vault is initialized and unlocked.
      </div>
    </div>

    <div class="card">
      <div class="label"><b>Step 1 ‚Äì Create or import key pair</b></div>
      <div class="row">
        <button class="btn primary" onclick="createKey()">Create keypair</button>
        <button class="btn" onclick="downloadPub()">Download pub</button>
        <button class="btn" onclick="exportPriv()">Export private</button>
        <input
          id="k_import_file"
          type="file"
          accept=".json"
          class="input"
          style="max-width:320px"
          onchange="importPriv(event)"
        >
      </div>
      <div class="label">Status</div>
      <pre id="k_status">No key yet.</pre>

      <div class="label">Public key (local)</div>
      <pre id="k_pub">(none)</pre>

      <div class="label">Private key (local ‚Äì NEVER share)</div>
      <div class="row">
        <pre id="k_priv" style="flex:1 1 auto;margin:0;">(hidden)</pre>
        <button class="btn" id="btnTogglePriv" onclick="togglePriv()">Show</button>
      </div>
    </div>

    <div class="card">
      <div class="label"><b>Step 2 ‚Äì Mindprint (your human pattern)</b></div>
      <textarea
        id="h_text"
        placeholder="Type 1‚Äì2 sentences with your own fingers‚Ä¶"
        onkeydown="logKey(event)"
        oninput="updateMindprint()"
      ></textarea>
      <div class="helper" id="h_status">Waiting for typing‚Ä¶</div>
    </div>
  </section>

  <!-- TAB: TRACE -->
  <section id="tab-trace" class="hide">
    <div class="card">
      <div class="label"><b>Step 3 ‚Äì Create TRACE badge</b></div>
      <div class="label">Text you want to sign</div>
      <textarea id="c_text" placeholder="Write/paste content‚Ä¶"></textarea>

      <div class="label" style="margin-top:8px">Attach image (optional)</div>
      <input
        id="c_image"
        type="file"
        accept="image/*"
        class="input"
        onchange="handleImage(event)"
      >
      <img id="c_thumb" class="hide" alt="Preview">

      <div class="label" style="margin-top:10px"><b>Step 3b ‚Äì Content Origin (Winston AI ‚Äì image only)</b></div>
      <div class="helper" id="co_status">Not analyzed yet.</div>
      <pre id="co_details" class="helper" style="white-space:pre-wrap;margin-top:4px;">‚Äì</pre>

      <div class="row" style="margin-top:8px">
        <button class="btn primary" onclick="buildBadge()">Analyze & create badge</button>
        <button class="btn" onclick="downloadSVG()">Download SVG</button>
        <button class="btn" onclick="downloadJSON()">Save proof (.json)</button>
      </div>

      <div class="label" style="margin-top:10px">Your TRACE badge (clickable)</div>
      <div id="b_preview" class="resultBox badgeFrame">
        <div class="helper">Badge will appear here after ‚ÄúAnalyze & create badge‚Äù.</div>
      </div>
      <div id="b_preview_hint" class="badgeClickableHint hide">
        Click the badge to jump directly to verification.
      </div>
    </div>
  </section>

  <!-- TAB: VERIFY -->
  <section id="tab-verify" class="hide">
    <div class="card">
      <div class="label"><b>Step 4 ‚Äì TraceNet (local)</b></div>
      <div class="label">creator_id</div>
      <div class="helper" id="tn_creator">(missing)</div>
      <div class="label" style="margin-top:6px">Registered?</div>
      <div class="helper" id="tn_regstatus">no</div>
    </div>

    <div class="card">
      <div class="label"><b>Step 5 ‚Äì Verify</b></div>
      <div class="row" style="margin-bottom:10px">
        <button class="btn primary" onclick="quickVerifyCurrent()">
          Verify my latest badge
        </button>
      </div>

      <div class="label">Upload badge (.svg)</div>
      <input id="v_file" type="file" accept=".svg,image/svg+xml" class="input">

      <div class="label" style="margin-top:8px">
        If the badge used an image: upload the same image here
      </div>
      <input id="v_img" type="file" accept="image/*" class="input">

      <div style="margin-top:10px">
        <button class="btn" onclick="smartVerify()">Verify uploaded badge</button>
      </div>

      <div class="label" style="margin-top:12px">Result</div>
      <div id="v_box" class="resultBox">
        <div id="v_human_status" class="bigStatus">No verification yet.</div>
        <div id="v_human_sub" class="subStatus">
          Click badge or upload a TRACE SVG.
        </div>
      </div>

      <!-- SIGNAL BREAKDOWN PANEL -->
      <div id="v_checks" class="check-list hide">
        <div class="bigStatus" style="margin-bottom:4px">Signal breakdown</div>

        <div class="check-row">
          <span class="check-label">Signature</span>
          <span id="chk_sign" class="check-pill check-na">N/A</span>
        </div>
        <div class="check-row">
          <span class="check-label">Time window (60s)</span>
          <span id="chk_time" class="check-pill check-na">N/A</span>
        </div>
        <div class="check-row">
          <span class="check-label">TraceNet identity</span>
          <span id="chk_creator" class="check-pill check-na">N/A</span>
        </div>
        <div class="check-row">
          <span class="check-label">Mindprint match</span>
          <span id="chk_mind" class="check-pill check-na">N/A</span>
        </div>
        <div class="check-row">
          <span class="check-label">Image hash</span>
          <span id="chk_img" class="check-pill check-na">N/A</span>
        </div>

        <div id="chk_summary" class="check-legend">
          Signal-score: ‚Äì/5. No checks run yet.
        </div>
      </div>
    </div>
  </section>

  <!-- TAB: VAULT -->
  <section id="tab-vault" class="hide">
    <div class="card">
      <div class="label"><b>BIO-ID Vault (identity & keys)</b></div>
      <div class="helper" id="vault_status">Vault locked.</div>

      <div class="label" style="margin-top:8px">Vault password</div>
      <div class="row">
        <input id="vault_pass" type="password" class="input" style="max-width:260px" placeholder="Choose password‚Ä¶">
        <button class="btn primary" id="vault_button" onclick="openVault()">Create & unlock</button>
      </div>
      <div class="helper" id="vault_error" style="color:#fca5a5;margin-top:4px;"></div>

      <div class="label" style="margin-top:12px">BIO-ID (creator_id)</div>
      <pre id="vault_creator">(locked)</pre>

      <div class="label">Public key</div>
      <pre id="vault_pub">(locked)</pre>

      <div class="label">Private key (local ‚Äì shown only here)</div>
      <pre id="vault_priv">(locked)</pre>

      <div class="label">Latest mindprint hash</div>
      <pre id="vault_mind">(locked)</pre>

      <div class="label">Mindprint created at</div>
      <pre id="vault_created">‚Äì</pre>
    </div>
  </section>

  <!-- TAB: ABOUT -->
  <section id="tab-about" class="hide">
    <div class="card">
      <div class="label"><b>How SignAi works ‚Äì simple view</b></div>
      <div class="helper">
        SignAi is a local-first system for proving that a piece of content
        (text + optional image) was created by a specific human, on a specific device,
        within a short time-window.
      </div>
      <ol class="helper" style="margin-left:18px;margin-top:6px">
        <li><b>Vault</b> ‚Äì You choose a password that unlocks your local BIO-ID Vault.</li>
        <li><b>Keys</b> ‚Äì SignAi generates an Ed25519 keypair and stores it only on this device.</li>
        <li><b>Mindprint</b> ‚Äì You type a few sentences; timing & rhythm become a <code>mind_hash</code>.</li>
        <li><b>TraceNet (local)</b> ‚Äì Your <code>creator_id</code> is derived from your public key and linked to your mindprint.</li>
        <li><b>TRACE badge</b> ‚Äì When you sign content, SignAi:
          <ul style="margin-left:16px">
            <li>Hashes the content and optional image</li>
            <li>Runs <b>ORIGIN-X</b> Backend-source (AI-detector X)</li>
            <li>Bundles everything into a signed <code>trace-7.0</code> token</li>
            <li>Renders a badge + glyph that encodes the payload</li>
          </ul>
        </li>
        <li><b>Verify</b> ‚Äì Anyone can load the badge and re-check:
          <ul style="margin-left:16px">
            <li>Signature (Ed25519)</li>
            <li>Time window (60 seconds)</li>
            <li>Creator identity (local TraceNet)</li>
            <li>Mindprint hash match</li>
            <li>Optional image hash match</li>
          </ul>
        </li>
      </ol>
      <div class="helper" style="margin-top:8px">
      </div>
    </div>

    <div class="card">
      <div class="label"><b>Advanced ‚Äì architecture & signals</b></div>
      <pre class="helper" style="white-space:pre-wrap">
‚Ä¢ Keys:
  ‚Äì WebCrypto Ed25519
  ‚Äì Public key exported as raw bytes ‚Üí base64url
  ‚Äì Private key stored locally as PKCS8 + base64url (never uploaded)

‚Ä¢ creator_id:
  ‚Äì &lt;creator_id&gt; = "sha256:" + SHA-256(JSON(publicKeyObject))
  ‚Äì Deterministic and device-agnostic; same key ‚Üí same creator_id

‚Ä¢ Mindprint:
  ‚Äì Logs keypress timestamps while you type
  ‚Äì Computes mean & variance of intervals, flatness, speed, etc.
  ‚Äì Hashes these features ‚Üí mind_hash (no raw timing stored)

‚Ä¢ Content Origin (ORIGIN-X hybrid, alpha):
  ‚Äì Text: light heuristic only (length, punctuation ratio)
  ‚Äì Image: dual-layer heuristic
      ¬∑ legacy: colorfulness, brightness, neighbor texture, per-channel variance
      ¬∑ ORIGIN-X: grayscale noise residuals (Laplacian), energy and structure
  ‚Äì Produces a 0‚Äì1 score:
      ¬∑ &lt; 0.45 ‚Üí Human-leaning (conservative)
      ¬∑ 0.45‚Äì0.75 ‚Üí Mixed / uncertain
      ¬∑ &gt; 0.75 ‚Üí AI-leaning (strong synthetic fingerprints)
  
    The scoring is biased to <b>avoid false AI flags</b> on real camera images.
(Not AI-backend source) 
‚Ä¢ TRACE token (trace-7.0):
  {
    version: "trace-7.0",
    scheme:  "signai-trace",
    content_type: "text/plain",
    content_hash: SHA-256(text),
    created_at:   iso8601,
    metadata: {
      creator_id,
      mindprint: { mind_hash },
      image_hash: (optional),
      content_origin: {
        score, label,
        text:  (light heuristic),
        image: (origin-x hybrid snapshot)
      },
      session: { issued_at, expires_in, nonce }
    },
    proof: {
      alg:     "Ed25519",
      edPublic,
      sig:     base64url(Ed25519_signature_over_canonical_payload)
    }
  }

‚Ä¢ Glyph:
  ‚Äì Seed = content_hash + image_hash + creator_id
  ‚Äì Seed ‚Üí SHA-256 ‚Üí hex pattern
  ‚Äì Hex pattern drives:
      ¬∑ 4√ó4 grid of animated circles
      ¬∑ palette (depends on content origin score)
      ¬∑ rotation and pulse timings
  ‚Äì Always the same for the same payload ‚Üí visual ‚ÄúDNA‚Äù of the badge.
      </pre>
    </div>
  </section>

  <footer class="helper">
    SignAi ¬© 2025 ‚Äî HOP 7.0 Alpha ‚Ä¢ All offline ‚Ä¢ WebCrypto Ed25519
  </footer>
</div>

<script>
/* ==== STORAGE WRAPPER ==== */
let MEMORY_STORAGE = {};
let STORAGE_WORKS = true;

try {
  localStorage.setItem("__signai_test", "1");
  localStorage.removeItem("__signai_test");
} catch (e) {
  STORAGE_WORKS = false;
  console.warn("localStorage BLOCKED ‚Äì using in-memory storage instead.");
}

const store = {
  set(key, val) {
    if (STORAGE_WORKS) localStorage.setItem(key, val);
    else MEMORY_STORAGE[key] = val;
  },
  get(key) {
    if (STORAGE_WORKS) return localStorage.getItem(key);
    return Object.prototype.hasOwnProperty.call(MEMORY_STORAGE, key)
      ? MEMORY_STORAGE[key]
      : null;
  },
  remove(key) {
    if (STORAGE_WORKS) localStorage.removeItem(key);
    else delete MEMORY_STORAGE[key];
  }
};

/* === CACHE ELEMENTS === */
const st1 = document.getElementById('st1');
const st2 = document.getElementById('st2');
const st3 = document.getElementById('st3');
const st4 = document.getElementById('st4');
const st5 = document.getElementById('st5');

const btnPrev = document.getElementById('btnPrev');
const btnNext = document.getElementById('btnNext');

const k_status   = document.getElementById('k_status');
const h_status   = document.getElementById('h_status');
const h_text     = document.getElementById('h_text');

const tn_creator   = document.getElementById('tn_creator');
const tn_regstatus = document.getElementById('tn_regstatus');

const c_text   = document.getElementById('c_text');
const c_image  = document.getElementById('c_image');
const c_thumb  = document.getElementById('c_thumb');
const b_preview      = document.getElementById('b_preview');
const b_preview_hint = document.getElementById('b_preview_hint');

const v_file  = document.getElementById('v_file');
const v_img   = document.getElementById('v_img');
const v_box   = document.getElementById('v_box');
const v_human_status = document.getElementById('v_human_status');
const v_human_sub    = document.getElementById('v_human_sub');
const signai_logo    = document.getElementById('signai_logo');

const v_checks_panel = document.getElementById('v_checks');
const chk_sign    = document.getElementById('chk_sign');
const chk_time    = document.getElementById('chk_time');
const chk_creator = document.getElementById('chk_creator');
const chk_mind    = document.getElementById('chk_mind');
const chk_img     = document.getElementById('chk_img');
const chk_summary = document.getElementById('chk_summary');

/* Vault DOM */
const vault_status  = document.getElementById('vault_status');
const vault_error   = document.getElementById('vault_error');
const vault_creator = document.getElementById('vault_creator');
const vault_pub     = document.getElementById('vault_pub');
const vault_priv    = document.getElementById('vault_priv');
const vault_mind    = document.getElementById('vault_mind');
const vault_created = document.getElementById('vault_created');
const vault_pass    = document.getElementById('vault_pass');
const vault_button  = document.getElementById('vault_button');

/* Content Origin DOM */
const co_status  = document.getElementById('co_status');
const co_details = document.getElementById('co_details');

/* Dashboard DOM */
const cd_creator_id    = document.getElementById('cd_creator_id');
const cd_vault_status  = document.getElementById('cd_vault_status');
const cd_mindprint     = document.getElementById('cd_mindprint');
const cd_origin_status = document.getElementById('cd_origin_status');
const dash_latest_badge = document.getElementById('dash_latest_badge');
const dash_verifications = document.getElementById('dash_verifications');

/* === NAV / UI === */
let currentTab = 'dashboard';
const tabOrder = ['dashboard','signai','trace','verify','vault','about'];

function switchTab(name, btn){
  currentTab = name;

  document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
  if(btn) btn.classList.add('active');

  ['dashboard','signai','trace','verify','vault','about'].forEach(n=>{
    const el = document.getElementById('tab-'+n);
    if(el) el.classList.add('hide');
  });
  const activeTab = document.getElementById('tab-'+name);
  if(activeTab) activeTab.classList.remove('hide');

  [st1,st2,st3,st4,st5].forEach(el=>el && el.classList.remove('active'));

  if(name === 'dashboard'){
    [st1,st2,st3,st4,st5].forEach(el=>el && el.classList.add('active'));
  }
  if(name === 'signai'){
    st1 && st1.classList.add('active');
    st2 && st2.classList.add('active');
    st3 && st3.classList.add('active');
  }
  if(name === 'trace'){
    st1 && st1.classList.add('active');
    st2 && st2.classList.add('active');
    st3 && st3.classList.add('active');
    st4 && st4.classList.add('active');
  }
  if(name === 'verify' || name === 'vault' || name === 'about'){
    st1 && st1.classList.add('active');
    st2 && st2.classList.add('active');
    st3 && st3.classList.add('active');
    st4 && st4.classList.add('active');
    st5 && st5.classList.add('active');
  }

  updatePager();
}

function goNext(){
  const i = tabOrder.indexOf(currentTab);
  if(i < tabOrder.length-1){
    const nextTab = tabOrder[i+1];
    switchTab(nextTab, document.getElementById('tb_'+nextTab));
  }
}
function goPrev(){
  const i = tabOrder.indexOf(currentTab);
  if(i > 0){
    const prevTab = tabOrder[i-1];
    switchTab(prevTab, document.getElementById('tb_'+prevTab));
  }
}
function updatePager(){
  const i = tabOrder.indexOf(currentTab);
  if(btnPrev) btnPrev.disabled = (i<=0);
  if(btnNext) btnNext.disabled = (i>=tabOrder.length-1);
}
switchTab('dashboard', document.getElementById('tb_dashboard'));

/* SignAi logo default (1.png) */
function applyLogos(){
  if(signai_logo && !signai_logo.getAttribute('src')){
    signai_logo.src = '1.png';
  }
}
applyLogos();

/* === ENCODER === */
const enc = new TextEncoder();

/* === BASE64URL HELPERS === */
function b64u(bytes){
  let s = btoa(String.fromCharCode(...bytes));
  return s.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
function fromB64u(s){
  const pad = '='.repeat((4-(s.length%4))%4);
  s = s.replace(/-/g,'+').replace(/_/g,'/') + pad;
  const bin = atob(s);
  const u = new Uint8Array(bin.length);
  for(let i=0;i<u.length;i++) u[i] = bin.charCodeAt(i);
  return u;
}

/* === SHA-256 via WebCrypto === */
async function sha256HexBuffer(buf){
  if(!window.crypto || !crypto.subtle){
    throw new Error('WebCrypto (crypto.subtle) not supported in this environment.');
  }
  const hashBuf = await crypto.subtle.digest('SHA-256', buf);
  const u = new Uint8Array(hashBuf);
  return [...u].map(b=>b.toString(16).padStart(2,'0')).join('');
}
async function sha256Hex(text){
  return sha256HexBuffer(enc.encode(text));
}

/* === ED25519 via WebCrypto === */
async function kpGenerate(){
  if(!window.crypto || !crypto.subtle){
    throw new Error('WebCrypto (crypto.subtle) not supported in this environment.');
  }
  const keyPair = await crypto.subtle.generateKey(
    { name: 'Ed25519' },
    true,
    ['sign','verify']
  );
  const pubRaw   = await crypto.subtle.exportKey('raw',   keyPair.publicKey);
  const privPkcs = await crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
  return {
    publicKey: new Uint8Array(pubRaw),
    privateKey: new Uint8Array(privPkcs)
  };
}

async function getStoredPrivateKey(){
  const raw = store.get('sa_priv');
  if(!raw) return null;
  const j = JSON.parse(raw);
  if(!j.edSecret) return null;
  const pkcs8Bytes = fromB64u(j.edSecret);
  return crypto.subtle.importKey(
    'pkcs8',
    pkcs8Bytes,
    { name: 'Ed25519' },
    false,
    ['sign']
  );
}

async function getStoredPublicKey(){
  const raw = store.get('sa_pub');
  if(!raw) return null;
  const j = JSON.parse(raw);
  if(!j.edPublic) return null;
  const pubBytes = fromB64u(j.edPublic);
  return crypto.subtle.importKey(
    'raw',
    pubBytes,
    { name: 'Ed25519' },
    false,
    ['verify']
  );
}

async function signBytesEd25519(msgBytes){
  const privKey = await getStoredPrivateKey();
  if(!privKey) throw new Error('No private ED25519 key found.');
  const sigBuf = await crypto.subtle.sign(
    { name: 'Ed25519' },
    privKey,
    msgBytes
  );
  return new Uint8Array(sigBuf);
}

async function verifyBytesEd25519(msgBytes, sigB64u, pubB64u){
  const sigBytes = fromB64u(sigB64u);
  const pubBytes = fromB64u(pubB64u);
  const pubKey = await crypto.subtle.importKey(
    'raw',
    pubBytes,
    { name: 'Ed25519' },
    false,
    ['verify']
  );
  return crypto.subtle.verify(
    { name: 'Ed25519' },
    pubKey,
    sigBytes,
    msgBytes
  );
}

/* === KEY MGMT === */
function setKeyStatus(msg){
  if(k_status) k_status.textContent = msg;
}

async function createKey(){
  try{
    const vaultHash = store.get('sa_vault_hash');
    const vaultUnlocked = store.get('sa_vault_unlocked') === '1';
    if(!vaultHash || !vaultUnlocked){
      alert('Set and unlock your BIO-ID Vault password first (Vault tab) before creating keys.');
      return;
    }

    const kp = await kpGenerate();
    store.set('sa_priv', JSON.stringify({ edSecret: b64u(kp.privateKey) }));
    store.set('sa_pub',  JSON.stringify({ edPublic: b64u(kp.publicKey) }));
    setKeyStatus('Keypair created locally with WebCrypto (Ed25519).');
    updateKeyDisplay();
    ensureTraceNetRegistered();
    loadVault();
  }catch(e){
    console.error(e);
    setKeyStatus('Error creating key: '+e.message);
  }
}
function downloadPub(){
  const pub = store.get('sa_pub');
  if(!pub){ alert('No public key.'); return; }
  const blob = new Blob([pub],{type:'application/json'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url; a.download = 'signai_public_key.json'; a.click();
  URL.revokeObjectURL(url);
}
function exportPriv(){
  const priv = store.get('sa_priv');
  if(!priv){ alert('No private key.'); return; }
  if(!confirm('Export private key? NEVER share this file.')) return;
  const blob = new Blob([priv],{type:'application/json'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url; a.download = 'signai_private_key.json'; a.click();
  URL.revokeObjectURL(url);
}
function importPriv(e){
  const f = e.target.files[0];
  if(!f) return;
  f.text().then(t=>{
    try{
      const j = JSON.parse(t);
      if(j.edSecret){
        store.set('sa_priv', JSON.stringify(j));
        setKeyStatus('Private key imported.');
        updateKeyDisplay();
        ensureTraceNetRegistered();
        loadVault();
      }else{
        throw new Error('Unknown key structure');
      }
    }catch(err){
      setKeyStatus('Error: '+err.message);
    }
  });
}

function updateKeyDisplay(){
  const pubEl = document.getElementById('k_pub');
  const privEl = document.getElementById('k_priv');
  const btn   = document.getElementById('btnTogglePriv');

  const pubRaw  = store.get('sa_pub');
  const privRaw = store.get('sa_priv');

  if(pubEl){
    if(pubRaw){
      try{
        const j = JSON.parse(pubRaw);
        pubEl.textContent = j.edPublic || '(unknown format)';
      }catch(e){
        pubEl.textContent = '(error reading public key)';
      }
    }else{
      pubEl.textContent = '(none)';
    }
  }

  if(privEl){
    if(privRaw){
      privEl.dataset.real = privRaw;
      privEl.dataset.shown = '0';
      privEl.textContent = '(hidden)';
      if(btn) btn.disabled = false;
    }else{
      privEl.dataset.real = '';
      privEl.dataset.shown = '0';
      privEl.textContent = '(none)';
      if(btn) btn.disabled = true;
    }
  }
}

function togglePriv(){
  const privEl = document.getElementById('k_priv');
  const btn    = document.getElementById('btnTogglePriv');
  if(!privEl || !btn) return;

  const real  = privEl.dataset.real || '';
  const shown = privEl.dataset.shown === '1';

  if(!real){
    privEl.textContent = '(none)';
    btn.disabled = true;
    return;
  }

  if(shown){
    privEl.textContent = '(hidden)';
    privEl.dataset.shown = '0';
    btn.textContent = 'Show';
  }else{
    privEl.textContent = real;
    privEl.dataset.shown = '1';
    btn.textContent = 'Hide';
  }
}

/* === MINDPRINT v2 === */
let h_log = [];
function logKey(e){
  h_log.push({ t: performance.now(), k: e.key });
}
function computeMindprint(){
  if(h_log.length < 8 || !h_text) return null;

  const ts = h_log.map(x=>x.t);
  const dt = [];
  for(let i=1;i<ts.length;i++){
    dt.push(ts[i]-ts[i-1]);
  }
  if(dt.length === 0) return null;

  const mean = dt.reduce((a,b)=>a+b,0)/dt.length;
  const varc = dt.reduce((a,b)=>a+(b-mean)*(b-mean),0)/dt.length;
  const sd   = Math.sqrt(varc);
  const flatRatio = dt.filter(x=>Math.abs(x-mean)<8).length/dt.length;

  const totalDuration = ts[ts.length-1] - ts[0];
  const textLen = h_text.value.length;
  const charsPerSec = totalDuration > 0 ? textLen / (totalDuration/1000) : 0;

  const backspaces = h_log.filter(x=>x.k==='Backspace').length;
  const spaces     = h_log.filter(x=>x.k===' ').length;
  const enters     = h_log.filter(x=>x.k==='Enter').length;

  return {
    version: 'mp-v2',
    meanInterval: mean,
    sdInterval: sd,
    flatRatio: flatRatio,
    totalDurationMs: totalDuration,
    length: textLen,
    charsPerSec: charsPerSec,
    backspaceFreq: backspaces / Math.max(1,textLen),
    spaceFreq: spaces / Math.max(1,textLen),
    enterCount: enters
  };
}
function updateMindprint(){
  const features = computeMindprint();
  if(!features) return;

  sha256Hex(JSON.stringify(features)).then(h=>{
    store.set('mindprint', JSON.stringify({
      mind_hash: h,
      created_at: new Date().toISOString()
    }));
    if(h_status) h_status.textContent = 'Human mindprint registered ‚úîÔ∏é';
    ensureTraceNetRegistered();
    loadVault();
  }).catch(err=>{
    console.error(err);
    if(h_status) h_status.textContent = 'Error hashing mindprint: '+err.message;
  });
}

/* === TraceNet (local) === */
function getTraceNet(){
  try{
    return JSON.parse(store.get('tracenet')||'{}');
  }catch(_e){
    return {};
  }
}
function putTraceNet(obj){
  store.set('tracenet', JSON.stringify(obj));
}
async function creatorId(pub){
  const h = await sha256Hex(JSON.stringify(pub));
  return 'sha256:'+h;
}
let lastCreatorId = null;

async function ensureTraceNetRegistered(){
  const pub = store.get('sa_pub');
  const mp  = store.get('mindprint');
  if(!pub || !mp) {
    renderTraceNetStatus();
    return;
  }
  const pubObj = JSON.parse(pub);
  const mpObj  = JSON.parse(mp);

  const id = 'sha256:'+await sha256Hex(JSON.stringify(pubObj));
  const tn = getTraceNet();
  if(!tn[id]){
    tn[id] = {
      public: pubObj,
      mind: mpObj.mind_hash,
      created_at: new Date().toISOString()
    };
  } else {
    tn[id].mind = mpObj.mind_hash;
    tn[id].updated_at = new Date().toISOString();
  }
  putTraceNet(tn);
  renderTraceNetStatus();
}

async function renderTraceNetStatus(){
  const pub = store.get('sa_pub');
  const tn = getTraceNet();

  if(!pub){
    if(tn_creator)   tn_creator.textContent = '(missing ‚Äì create key first)';
    if(tn_regstatus) tn_regstatus.textContent = 'No ‚Äì no public key yet.';
    lastCreatorId = null;
    renderCreatorDashboard();
    return;
  }

  const pubObj = JSON.parse(pub);
  const cid = 'sha256:'+await sha256Hex(JSON.stringify(pubObj));
  lastCreatorId = cid;

  if(tn_creator) tn_creator.textContent = cid;

  if(tn_regstatus){
    let base = tn[cid]
      ? 'Yes ‚Äì registered locally.'
      : 'No ‚Äì not found in local TraceNet.';
    if(!STORAGE_WORKS){
      base += ' (Sandbox mode without persistent storage).';
    }
    tn_regstatus.textContent = base;
  }

  renderCreatorDashboard();
}

/* === VAULT === */
async function renderVault(){
  if(!vault_status) return;
  const unlocked   = store.get('sa_vault_unlocked') === '1';
  const storedHash = store.get('sa_vault_hash');

  if(unlocked){
    vault_status.textContent = 'Vault is unlocked on this device.';
    if(vault_error) vault_error.textContent = '';
    if(vault_button){
      vault_button.textContent = 'Lock';
      vault_button.onclick = lockVault;
    }
    if(vault_pass){
      vault_pass.placeholder = 'Vault unlocked';
      vault_pass.value = '';
    }

    const pubRaw  = store.get('sa_pub');
    const privRaw = store.get('sa_priv');
    const mpRaw   = store.get('mindprint');

    let cid = '(missing)';
    if(pubRaw){
      try{
        const pubObj = JSON.parse(pubRaw);
        cid = 'sha256:'+await sha256Hex(JSON.stringify(pubObj));
        if(vault_pub)  vault_pub.textContent  = pubObj.edPublic || '(unknown format)';
      }catch(e){
        if(vault_pub) vault_pub.textContent = '(error reading public key)';
      }
    }else{
      if(vault_pub) vault_pub.textContent = '(no key yet)';
    }

    if(vault_creator) vault_creator.textContent = cid;

    if(privRaw){
      if(vault_priv) vault_priv.textContent = privRaw;
    }else{
      if(vault_priv) vault_priv.textContent = '(no private key yet)';
    }

    if(mpRaw){
      try{
        const mpObj = JSON.parse(mpRaw);
        if(vault_mind)    vault_mind.textContent    = mpObj.mind_hash || '(missing)';
        if(vault_created) vault_created.textContent = mpObj.created_at || '(unknown)';
      }catch(e){
        if(vault_mind)    vault_mind.textContent    = '(error reading mindprint)';
        if(vault_created) vault_created.textContent = '‚Äì';
      }
    }else{
      if(vault_mind)    vault_mind.textContent    = '(no mindprint yet)';
      if(vault_created) vault_created.textContent = '‚Äì';
    }

  }else{
    vault_status.textContent = storedHash
      ? 'Vault locked. Enter your password to unlock.'
      : 'No Vault password set. Choose a password to create your BIO-ID Vault.';
    if(vault_error) vault_error.textContent = '';
    if(vault_button){
      vault_button.textContent = storedHash ? 'Unlock' : 'Create & unlock';
      vault_button.onclick = openVault;
    }
    if(vault_pass){
      vault_pass.placeholder = storedHash ? 'Password‚Ä¶' : 'Choose new password‚Ä¶';
      vault_pass.value = '';
    }
    if(vault_creator) vault_creator.textContent = '(locked)';
    if(vault_pub)     vault_pub.textContent     = '(locked)';
    if(vault_priv)    vault_priv.textContent    = '(locked)';
    if(vault_mind)    vault_mind.textContent    = '(locked)';
    if(vault_created) vault_created.textContent = '‚Äì';
  }

  renderCreatorDashboard();
}

function loadVault(){
  renderVault();
}

async function openVault(){
  if(!vault_pass) return;
  const pass = vault_pass.value || '';
  const storedHash = store.get('sa_vault_hash');

  if(!storedHash){
    if(!pass){
      if(vault_error) vault_error.textContent = 'Choose a password first.';
      return;
    }
    const h = await sha256Hex(pass);
    store.set('sa_vault_hash', h);
    store.set('sa_vault_unlocked','1');
    await renderVault();
  }else{
    const h = await sha256Hex(pass);
    if(h === storedHash){
      store.set('sa_vault_unlocked','1');
      await renderVault();
    }else{
      if(vault_error) vault_error.textContent = 'Wrong password.';
    }
  }
}

function lockVault(){
  store.set('sa_vault_unlocked','0');
  renderVault();
}

/* === DASHBOARD RENDER === */
let lastOriginInfo = null;
let lastToken = null;
let lastSvg   = null;
let verificationLog = [];

function renderCreatorDashboard(){
  if(cd_creator_id){
    if(lastCreatorId){
      cd_creator_id.textContent = lastCreatorId;
    }else{
      cd_creator_id.textContent = '(no key yet)';
    }
  }

  if(cd_vault_status){
    const unlocked   = store.get('sa_vault_unlocked') === '1';
    const storedHash = store.get('sa_vault_hash');
    if(!storedHash){
      cd_vault_status.textContent = 'Not initialized';
    }else if(unlocked){
      cd_vault_status.textContent = 'Unlocked on this device';
    }else{
      cd_vault_status.textContent = 'Locked';
    }
  }

  if(cd_mindprint){
    const mpRaw = store.get('mindprint');
    if(mpRaw){
      try{
        const mp = JSON.parse(mpRaw);
        cd_mindprint.textContent = 'Registered ¬∑ '+(mp.created_at || '').slice(0,19).replace('T',' ');
      }catch(_e){
        cd_mindprint.textContent = 'Registered';
      }
    }else{
      cd_mindprint.textContent = 'Not registered yet';
    }
  }

  if(cd_origin_status){
    if(lastOriginInfo){
      cd_origin_status.textContent =
        lastOriginInfo.label+' ¬∑ score '+lastOriginInfo.score.toFixed(3);
    }else{
      cd_origin_status.textContent = 'No analysis yet';
    }
  }

  if(dash_latest_badge){
    if(!lastToken){
      dash_latest_badge.innerHTML =
        'No badge created yet. Go to TRACE and create your first badge.';
    }else{
      const t = lastToken;
      const origin = t.metadata?.content_origin;
      const when = (t.created_at || t.metadata?.session?.issued_at || '').slice(0,19).replace('T',' ');
      const cid = t.metadata?.creator_id || '(unknown)';
      const originLabel = origin?.label || 'n/a';
      const originScore = typeof origin?.score === 'number' ? origin.score.toFixed(3) : 'n/a';

      dash_latest_badge.innerHTML =
        `<div class="badge-summary">
          <div><b>Status:</b> latest TRACE badge created.</div>
          <div><b>Time:</b> ${when || '(unknown)'}</div>
          <div><b>Creator:</b> <code>${cid}</code></div>
          <div><b>Content origin:</b> ${originLabel} (score ${originScore})</div>
          <div style="margin-top:6px;font-size:11px;color:#9fb0c4;">
            Full visual badge is shown under TRACE and used automatically in Verify.
          </div>
        </div>`;
    }
  }

  renderVerificationLog();
}

function renderVerificationLog(){
  if(!dash_verifications) return;
  if(!verificationLog.length){
    dash_verifications.textContent =
      'No verifications yet. Verify a badge to see it here.';
    return;
  }
  let html = '<table class="table-mini"><thead><tr><th>Time</th><th>Status</th><th>Creator</th><th>Origin</th></tr></thead><tbody>';
  verificationLog.slice(0,5).forEach(item=>{
    let cls = 'status-ok';
    let label = 'verified';
    if(item.status === 'failed'){ cls='status-fail'; label='failed'; }
    if(item.status === 'expired'){ cls='status-expired'; label='expired'; }
    html += `<tr>
      <td>${item.time.slice(0,19).replace('T',' ')}</td>
      <td><span class="status-pill ${cls}">${label}</span></td>
      <td><code>${item.creatorId || '(n/a)'}</code></td>
      <td>${item.origin || 'n/a'}</td>
    </tr>`;
  });
  html += '</tbody></table>';
  dash_verifications.innerHTML = html;
}

/* === TRACE BADGE === */
let attachedImageFile = null;
let attachedImageHash = null;
let attachedThumbDataURL = null;
let attachedImageFeatures = null;
let badgeTimerInterval = null;

async function handleImage(e){
  const f = e.target.files[0];
  if(!f) return;

  attachedImageFile = f;

  const buf = await f.arrayBuffer();
  attachedImageHash = await sha256HexBuffer(buf);
  attachedImageFeatures = null;

  const img = new Image();
  img.onload = ()=>{
    const can = document.createElement('canvas');
    const maxW = 260;
    const scale = Math.min(1, maxW / img.width);
    can.width = Math.round(img.width * scale);
    can.height = Math.round(img.height * scale);
    const ctx = can.getContext('2d');
    ctx.drawImage(img,0,0,can.width,can.height);
    attachedThumbDataURL = can.toDataURL('image/png',0.9);
    if(c_thumb){
      c_thumb.src = attachedThumbDataURL;
      c_thumb.classList.remove('hide');
    }

    /* small working canvas for ORIGIN-X */
    const size = 96;
    const featCanvas = document.createElement('canvas');
    featCanvas.width = size;
    featCanvas.height = size;
    const fctx = featCanvas.getContext('2d');
    fctx.drawImage(img,0,0,size,size);
    const data = fctx.getImageData(0,0,size,size).data;

    let sumR=0,sumG=0,sumB=0;
    let sumR2=0,sumG2=0,sumB2=0;
    let sumRG=0,sumRG2=0;
    let sumYB=0,sumYB2=0;
    let totalDiff=0;
    let count=0;
    const w=size,h=size;

    const gray = new Float32Array(w*h);

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const idx=(y*w+x)*4;
        const r=data[idx],g=data[idx+1],b=data[idx+2];
        sumR+=r; sumG+=g; sumB+=b;
        sumR2+=r*r; sumG2+=g*g; sumB2+=b*b;

        const rg=r-g;
        const yb=(r+g)/2 - b;
        sumRG+=rg; sumRG2+=rg*rg;
        sumYB+=yb; sumYB2+=yb*yb;

        if(x>0){
          const idxL=(y*w+(x-1))*4;
          const rl=data[idxL],gl=data[idxL+1],bl=data[idxL+2];
          totalDiff+=Math.abs(r-rl)+Math.abs(g-gl)+Math.abs(b-bl);
        }
        if(y>0){
          const idxT=((y-1)*w+x)*4;
          const rt=data[idxT],gt=data[idxT+1],bt=data[idxT+2];
          totalDiff+=Math.abs(r-rt)+Math.abs(g-gt)+Math.abs(b-bt);
        }
        const gval = 0.299*r+0.587*g+0.114*b;
        gray[y*w+x] = gval;
        count++;
      }
    }

    const N=count||1;
    const meanR=sumR/N,meanG=sumG/N,meanB=sumB/N;
    const varR=sumR2/N-meanR*meanR;
    const varG=sumG2/N-meanG*meanG;
    const varB=sumB2/N-meanB*meanB;
    const brightness=(meanR+meanG+meanB)/3;

    const meanRG=sumRG/N,meanYB=sumYB/N;
    const varRG=sumRG2/N-meanRG*meanRG;
    const varYB=sumYB2/N-meanYB*meanYB;

    const stdRG=Math.sqrt(Math.max(varRG,0));
    const stdYB=Math.sqrt(Math.max(varYB,0));
    const colorfulness=Math.sqrt(stdRG*stdRG+stdYB*stdYB)+0.3*Math.sqrt(meanRG*meanRG+meanYB*meanYB);

    const diffsCount = (w*h*2 - w - h);
    const avgNeighborDiff = diffsCount>0 ? totalDiff/diffsCount : 0;

    /* ORIGIN-X noise residual (enkel Laplacian) */
    let sumLap2 = 0;
    let sumAbsLap = 0;
    let lapCount = 0;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const c = gray[y*w+x];
        const up = gray[(y-1)*w+x];
        const dn = gray[(y+1)*w+x];
        const lf = gray[y*w+(x-1)];
        const rt = gray[y*w+(x+1)];
        const lap = 4*c - (up+dn+lf+rt);
        sumLap2 += lap*lap;
        sumAbsLap += Math.abs(lap);
        lapCount++;
      }
    }
    const lapRms = lapCount>0 ? Math.sqrt(sumLap2/lapCount) : 0;
    const lapMeanAbs = lapCount>0 ? (sumAbsLap/lapCount) : 0;
    const noiseEnergy = lapRms + 0.3*lapMeanAbs;

    attachedImageFeatures = {
      legacy: {
        brightness,
        varR, varG, varB,
        colorfulness,
        avgNeighborDiff
      },
      originx: {
        brightness,
        colorfulness,
        avgNeighborDiff,
        lapRms,
        lapMeanAbs,
        noiseEnergy
      }
    };
  };
  img.src = URL.createObjectURL(f);
}

function canonicalize(o){
  if(o===null || typeof o!=='object') return o;
  if(Array.isArray(o)) return o.map(canonicalize);
  const out={};
  Object.keys(o).sort().forEach(k=>{ out[k] = canonicalize(o[k]); });
  return out;
}
function canonicalJSONString(o){
  return JSON.stringify(canonicalize(o));
}

function startBadgeCountdown(targetMs){
  if(badgeTimerInterval){
    clearInterval(badgeTimerInterval);
    badgeTimerInterval = null;
  }
  if(!b_preview) return;
  const svgRoot = b_preview.querySelector('svg');
  if(!svgRoot) return;

  const textEl = svgRoot.querySelector('#timerText');
  const dotEl  = svgRoot.querySelector('#timerDot');

  function tick(){
    const now = Date.now();
    let remaining = Math.round((targetMs - now)/1000);
    if(remaining < 0) remaining = 0;
    if(textEl){
      textEl.textContent = remaining + 's';
    }
    if(remaining <= 0){
      if(dotEl) dotEl.setAttribute('fill','#3b82f6');
      clearInterval(badgeTimerInterval);
      badgeTimerInterval = null;
    }
  }

  tick();
  badgeTimerInterval = setInterval(tick,1000);
}

/* === CONTENT ORIGIN (ORIGIN-X HYBRID) === */
async function analyzeContent(txt, imgFeatures, imgHash){
  // Neutral fallback om Winston AI inte svarar.
  // Ingen lokal AI-detektion g√∂rs h√§r.
  return {
    score: 0.5,
    label: 'Unknown (Winston offline)',
    explanation: 'Winston AI kunde inte n√•s ‚Äì ingen lokal AI-detektor anv√§nds, endast neutral fallback.',
    text: null,
    image: null
  };
}





async function callOnlineAIDetector(file){
  const form = new FormData();
  form.append("image", file);

  try{
    const res = await fetch("https://signai-tamy.onrender.com/detect-image", {
      method: "POST",
      body: form
    });

    let data = null;
    try {
      data = await res.json();
    } catch(e) {
      console.error("Backend responded with non-JSON:", e);
      return {
        ai_score: 0.5,
        label: "Backend returned non-JSON (status " + res.status + ")",
        version: "signai-backend",
        raw: null
      };
    }

    console.log("üîç Winston backend raw response:", data)
    if (!res.ok) {
      const lbl = data && data.label
        ? "Backend error: " + data.label
        : "Backend HTTP error: " + res.status;

      return {
        ai_score: 0.5,
        label: lbl,
        version: data.version || "signai-backend",
        raw: data
      };
    }

    let aiScore =
      (typeof data.ai_score === "number" && data.ai_score) ??
      (typeof data.score === "number" && data.score) ??
      (typeof data.probability === "number" && data.probability) ??
      null;

    if (aiScore !== null && aiScore > 1) {
      aiScore = aiScore / 100;
    }

    let label = data.label;
    if (!label && typeof data.is_ai === "boolean") {
      label = data.is_ai ? "AI" : "Human";
    }
    if (!label && typeof data.is_human === "boolean") {
      label = data.is_human ? "Human" : "AI";
    }

    const version = data.version || data.model || data.engine || "winston-ai";

    if (aiScore === null) aiScore = 0.5;
    if (!label)          label   = "Unknown";

    return {
      ai_score: aiScore,
      label,
      version,
      raw: data
    };
  }catch(err){
    console.error("fetch() to backend failed:", err);
    return {
      ai_score: 0.5,
      label: "Network error contacting backend: " + err.message,
      version: "signai-backend",
      raw: null
    };
  }
}


/* BIO-ID glyph */
async function buildGlyphSvg(seed, originScore){
  const h = await sha256Hex(seed);

  const humanPalette  = ['#22b7ff','#22e0d8','#4ade80','#22c55e'];
  const mixedPalette  = ['#22b7ff','#22e0d8','#a855f7','#38bdf8'];
  const aiPalette     = ['#f97316','#fb7185','#a855f7','#facc15'];

  let colors;
  if(typeof originScore === 'number'){
    if(originScore < 0.35) colors = humanPalette;
    else if(originScore > 0.65) colors = aiPalette;
    else colors = mixedPalette;
  }else{
    colors = mixedPalette;
  }

  const gridSize = 4;
  const cellSize = 22;
  const margin = 10;
  let shapes = '';

  for(let i=0;i<gridSize*gridSize;i++){
    const hex = h[i];
    const val = parseInt(hex,16);
    if((val % 2) === 0){
      const row = Math.floor(i / gridSize);
      const col = i % gridSize;
      const cx = margin + cellSize/2 + col*cellSize;
      const cy = margin + cellSize/2 + row*cellSize;
      const r  = 4 + (val % 4);
      const color = colors[val % colors.length];
      shapes += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${color}" opacity="0.9">
        <animate attributeName="r" values="${r};${r+1.5};${r}" dur="${1+val/32}s" repeatCount="indefinite"/>
      </circle>`;
    }
  }

  return `  <g id="trace_fp" transform="translate(20,22)">
    <rect x="0" y="0" width="140" height="126" rx="22"
          fill="#020617" stroke="#1e293b" stroke-width="1.2"/>
    <rect x="3" y="3" width="134" height="120" rx="20"
          fill="#020617" stroke="#111827" stroke-width="1"/>
    <rect x="3" y="3" width="134" height="120" rx="20"
          fill="none" stroke="#1d4ed8" stroke-width="0.8" opacity="0.65"/>

    <g transform="translate(14,14)">
      <g>
        ${shapes}
        <animateTransform attributeName="transform"
          type="rotate"
          from="0 44 44"
          to="360 44 44"
          dur="18s"
          repeatCount="indefinite"/>
      </g>
    </g>

    <g transform="translate(10,102)">
      <rect x="0" y="0" width="32" height="16" rx="7"
            fill="#020617" stroke="#1e293b" stroke-width="1"/>
      <text x="16" y="11" text-anchor="middle"
            font-family="system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif"
            font-size="9" fill="#a5b4fc">ORIGIN</text>

      <rect x="38" y="0" width="34" height="16" rx="7"
            fill="#020617" stroke="#1e293b" stroke-width="1"/>
      <text x="55" y="11" text-anchor="middle"
            font-family="system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif"
            font-size="9" fill="#a5b4fc">HUMAN</text>

      <rect x="78" y="0" width="32" height="16" rx="7"
            fill="#020617" stroke="#1e293b" stroke-width="1"/>
      <text x="94" y="11" text-anchor="middle"
            font-family="system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif"
            font-size="9" fill="#a5b4fc">TT</text>
    </g>
  </g>`;
}


function renderContentOrigin(info){
    const co_status = document.getElementById('co_status');
    const co_details = document.getElementById('co_details');

    if(!info){
        if(co_status) co_status.textContent = 'Analyzing content origin‚Ä¶';
        if(co_details) co_details.textContent = '';
        return;
    }

    let scoreTxt = (info.score !== undefined)
        ? (info.score * 100).toFixed(1) + '%'
        : 'N/A';

    if(co_status){
        co_status.textContent = `${info.label} (${scoreTxt})`;
    }

    if(co_details){
        let lines = [];

        if(info.text){
            lines.push(`TEXT SCORE: ${(info.text.score * 100).toFixed(1)}% ‚Üí ${info.text.label}`);
            lines.push(`Words: ${info.text.words}`);
            lines.push(`Punctuation-per-word: ${info.text.punctuationPerWord.toFixed(3)}`);
            lines.push('');
        }

        if(info.image){
            lines.push(`IMAGE SCORE: ${(info.image.score * 100).toFixed(1)}% ‚Üí ${info.image.label}`);
            if(info.image.hash) lines.push(`Image hash: ${info.image.hash}`);
            lines.push('');
        }

        if(info.explanation){
            lines.push('EXPLANATION:');
            lines.push(info.explanation);
            lines.push('');
        }

        co_details.textContent = lines.join('\n');
    }
}



async function buildAIBadge(hash, originInfo){
    return `
<svg width="420" height="200" xmlns="http://www.w3.org/2000/svg">
  <rect width="420" height="200" rx="18" fill="#2b0000" stroke="#ff4444" stroke-width="2"/>
  <text x="20" y="40" fill="#ff7777" font-size="24" font-weight="700">
    AI-GENERATED CONTENT
  </text>
  <text x="20" y="80" fill="#ffaa88" font-size="16">
    Origin Score: ${(originInfo.score*100).toFixed(1)}%
  </text>
  <text x="20" y="110" fill="#ffaa88" font-size="16">
    Classification: ${originInfo.label}
  </text>
  <text x="20" y="150" fill="#ff9999" font-size="14">
    Content Hash:
  </text>
  <text x="20" y="170" fill="#ffdddd" font-size="12" style="opacity:0.9;">
    ${hash}
  </text>
</svg>`;
}

async function buildNeutralBadge(hash, originInfo){
    return `
<svg width="420" height="200" xmlns="http://www.w3.org/2000/svg">
  <rect width="420" height="200" rx="18" fill="#1e1e2a" stroke="#7aa7ff" stroke-width="2"/>
  <text x="20" y="40" fill="#bcd3ff" font-size="22" font-weight="700">
    MIXED / UNCERTAIN ORIGIN
  </text>
  <text x="20" y="80" fill="#e0e8ff" font-size="16">
    Score: ${(originInfo.score*100).toFixed(1)}%
  </text>
  <text x="20" y="110" fill="#e0e8ff" font-size="16">
    Label: ${originInfo.label}
  </text>
  <text x="20" y="150" fill="#aaccff" font-size="14">
    Hash:
  </text>
  <text x="20" y="170" fill="#d5e4ff" font-size="12">
    ${hash}
  </text>
</svg>`;
}


async function buildBadge(){
  try{
    const txt = c_text ? (c_text.value || '') : '';
    if(!txt.trim()){
      alert('Write or paste some text first.');
      return;
    }
    const privRaw = store.get('sa_priv');
    const pubRaw  = store.get('sa_pub');
    if(!privRaw || !pubRaw){
      alert('Create/import key first (Step 1).');
      return;
    }
    const mpRaw = store.get('mindprint');
    if(!mpRaw){
      alert('Create your mindprint first (Step 2).');
      return;
    }

    if(co_status) co_status.textContent = 'Analyserar inneh√•ll via Winston AI‚Ä¶';
    renderContentOrigin(null);

    let originInfo;

    if(attachedImageFile){
      try{
        const online = await callOnlineAIDetector(attachedImageFile);

        originInfo = {
          score: online.ai_score,
          label: online.label,
          explanation:
            "Winston AI image detection: score " +
            online.ai_score.toFixed(3) +
            " ‚Üí " + online.label +
            " (model: " + (online.version || "winston-ai") + ")",
          text: null,
          image: {
            score: online.ai_score,
            label: online.label,
            hash: attachedImageHash || null
          }
        };
      }catch(err){
        console.error("Winston AI call failed:", err);
        originInfo = await analyzeContent(txt, null, attachedImageHash);
      }
    }else{
      originInfo = {
        score: 0.30,
        label: 'Human (no image, not scanned)',
        explanation: 'Ingen bild bifogad. Winston AI k√∂rs endast p√• bilder. Texten √§r inte AI-skannad, bara signerad med ditt BIO-ID.',
        text: null,
        image: null
      };
    }

    let badgeType = "human";
    if(originInfo.score > 0.70){
      badgeType = "ai";
    } else if(originInfo.score >= 0.40){
      badgeType = "mixed";
    }

    lastOriginInfo = originInfo;
    renderContentOrigin(originInfo);
    renderCreatorDashboard();

    const mp   = JSON.parse(mpRaw);
    const content_hash = await sha256Hex(txt);
    const session = {
      issued_at: new Date().toISOString(),
      expires_in: 60,
      nonce: [...crypto.getRandomValues(new Uint8Array(8))]
        .map(b=>b.toString(16).padStart(2,'0')).join('')
    };
    const pubJ = JSON.parse(pubRaw);

    const tokenCore = {
      version: 'trace-7.0',
      scheme: 'signai-trace',
      content_type: 'text/plain',
      content_hash,
      created_at: session.issued_at,
      metadata: {
        creator_id: await creatorId(pubJ),
        mindprint: { mind_hash: mp.mind_hash },
        image_hash: attachedImageHash || null,
        content_origin: {
          score: originInfo.score,
          label: originInfo.label,
          text: originInfo.text || null,
          image: originInfo.image || null
        },
        session
      }
    };

    const msg = enc.encode(canonicalJSONString(tokenCore));
    const sig = await signBytesEd25519(msg);

    const token = {
      ...tokenCore,
      proof: {
        alg: 'Ed25519',
        edPublic: pubJ.edPublic,
        sig: b64u(sig)
      }
    };
    lastToken = token;

    const encoded   = btoa(unescape(encodeURIComponent(JSON.stringify(token))));
    const humanCode = ('HUMAN: '+(await sha256Hex(
      content_hash+(attachedImageHash||'')+session.nonce
    )).slice(0,10)).toUpperCase();

    const thumb = attachedThumbDataURL
      ? `<g transform="translate(134,18)">
           <rect x="0" y="0" width="40" height="40" rx="12"
                 fill="#020617" stroke="#22b7ff" stroke-width="1.2">
             <animate attributeName="stroke-width"
                      values="1.2;2;1.2"
                      dur="2.4s"
                      repeatCount="indefinite"/>
           </rect>
           <rect x="0" y="0" width="40" height="40" rx="12"
                 fill="none" stroke="#22e0d8" stroke-width="0.6" opacity="0.6">
             <animate attributeName="opacity"
                      values="0.4;1;0.4"
                      dur="3.5s"
                      repeatCount="indefinite"/>
           </rect>
           <image href="${attachedThumbDataURL}" x="4" y="4" width="32" height="32"
                  preserveAspectRatio="xMidYMid slice" opacity="0.98"/>
         </g>`
      : '';

    const glyphSeed = content_hash + '|' + (attachedImageHash || '') + '|' + token.metadata.creator_id;
    const glyph = await buildGlyphSvg(glyphSeed, originInfo.score);

    const svg =
`<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 420 170"
     width="420" height="170"
     data-trace="${encoded}"
     role="img"
     aria-label="SignAi BIO-ID ‚Äî Proof of Origin (Winston AI)">

  <defs>
    <linearGradient id="bg_grad" x1="0" y="0" x2="1" y="1">
      <stop offset="0" stop-color="#020617"/>
      <stop offset="0.4" stop-color="#020824"/>
      <stop offset="1" stop-color="#020617"/>
    </linearGradient>

    <linearGradient id="border_grad" x1="0" y="0" x2="1" y2="0">
      <stop offset="0" stop-color="#22b7ff"/>
      <stop offset="0.5" stop-color="#22e0d8"/>
      <stop offset="1" stop-color="#5b21ff"/>
    </linearGradient>

    <style>
      .title   { font: 800 18px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; fill:#e5f2ff; }
      .label   { font: 600 11px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; fill:#9fb0c4; }
      .value   { font: 700 12px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; fill:#cfe8ff; }
      .code    { font: 700 12px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; letter-spacing:0.08em; }
      .chip    { font: 700 9px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; fill:#a5b4fc; }
    </style>
  </defs>

  <rect x="0.5" y="0.5" width="419" height="169" rx="22"
        fill="url(#bg_grad)"/>
  <rect x="1.5" y="1.5" width="417" height="167" rx="21"
        fill="none" stroke="url(#border_grad)" stroke-width="1.4"/>

  <g transform="translate(396,18)">
    <circle id="timerDot" cx="0" cy="0" r="6" fill="#16a34a">
      <animate attributeName="r" values="6;7.5;6" dur="1.6s" repeatCount="indefinite"/>
      <animate attributeName="opacity" values="0.35;1;0.35" dur="1.6s" repeatCount="indefinite"/>
    </circle>
  </g>

${glyph}
${thumb}

  <g transform="translate(20,144)">
    <rect x="0" y="-18" width="220" height="22" rx="10"
          fill="#020617" stroke="#1e293b" stroke-width="1"/>
    <text x="10" y="-4" class="code" fill="#f9fafb">
      ${humanCode}
    </text>
  </g>

  <g transform="translate(190,34)">
    <text x="0" y="0" class="label">
      SIGNAI / HOP 7.0 BIO-ID
    </text>

    <text x="0" y="24" class="title">
      ORIGIN VIA WINSTON AI
    </text>

    <text x="0" y="46" class="label">
      MODE
    </text>
    <text x="84" y="46" class="value">
      Proof of Origin (BIO-ID + Winston)
    </text>

    <text x="0" y="64" class="label">
      WINDOW
    </text>
    <text x="84" y="64" class="value">
      TRACE ¬∑ <tspan id="timerText">60s</tspan> window
    </text>

    <text x="0" y="82" class="label">
      CREATOR_ID
    </text>
    <text x="84" y="82" class="value">
      ${token.metadata.creator_id}
    </text>

    <text x="0" y="100" class="label">
      CONTENT ORIGIN
    </text>
    <text x="84" y="100" class="value">
      ${originInfo.label}
    </text>

    <text x="0" y="118" class="label">
      ORIGIN SCORE
    </text>
    <text x="84" y="118" class="value" fill="#bbf7d0">
      ${(originInfo.score*100).toFixed(1)} %
    </text>

    <g transform="translate(0,132)">
      <rect x="0"  y="0" width="60" height="18" rx="9"
            fill="#020617" stroke="#1e293b"/>
      <text x="30" y="13" text-anchor="middle" class="chip">
        ORIGIN
      </text>

      <rect x="68" y="0" width="60" height="18" rx="9"
            fill="#020617" stroke="#1e293b"/>
      <text x="98" y="13" text-anchor="middle" class="chip">
        MINDPRINT
      </text>

      <rect x="136" y="0" width="60" height="18" rx="9"
            fill="#020617" stroke="#1e293b"/>
      <text x="166" y="13" text-anchor="middle" class="chip">
        TRACE¬∑TT
      </text>
    </g>
  </g>
</svg>`;

    lastSvg = svg;
    if(b_preview){
      b_preview.innerHTML = svg;
      b_preview.classList.add('clickable');
      b_preview.onclick = ()=>{
        quickVerifyCurrent();
        const tb = document.getElementById('tb_verify');
        switchTab('verify', tb);
      };
    }
    if(b_preview_hint){
      b_preview_hint.classList.remove('hide');
    }

    const expiresAt = new Date(session.issued_at).getTime() + session.expires_in*1000;
    startBadgeCountdown(expiresAt);
    renderCreatorDashboard();

  }catch(err){
    console.error(err);
    alert('Error creating badge: '+err.message);
  }
}


function downloadSVG(){
  if(!lastSvg){
    alert('No badge yet.');
    return;
  }
  const blob = new Blob([lastSvg],{type:'image/svg+xml'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url;
  a.download = 'signai_hop7_badge.svg';
  a.click();
  URL.revokeObjectURL(url);
}
function downloadJSON(){
  if(!lastToken){
    alert('No badge yet.');
    return;
  }
  const blob = new Blob([JSON.stringify(lastToken,null,2)],{type:'application/json'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url;
  a.download = 'signai_trace_token.json';
  a.click();
  URL.revokeObjectURL(url);
}

/* === VERIFY === */
function vSetVisual(statusLabel, subText, boxMode){
  if(v_human_status) v_human_status.textContent = statusLabel;
  if(v_human_sub)    v_human_sub.textContent    = subText;
  if(v_box){
    v_box.className = 'resultBox';
    if(boxMode==='ok')      v_box.classList.add('ok');
    if(boxMode==='bad')     v_box.classList.add('bad');
    if(boxMode==='expired') v_box.classList.add('expired');
  }
}

function resetChecks(){
  if(!v_checks_panel) return;
  v_checks_panel.classList.add('hide');

  [chk_sign, chk_time, chk_creator, chk_mind, chk_img].forEach(el=>{
    if(!el) return;
    el.className = 'check-pill check-na';
    el.textContent = 'N/A';
  });
  if(chk_summary){
    chk_summary.textContent = 'Signal-score: ‚Äì/5. No checks yet.';
  }
}
function setCheck(el, state){
  if(!el) return;
  el.className = 'check-pill';
  if(state === 'ok'){
    el.classList.add('check-ok');
    el.textContent = 'OK';
  }else if(state === 'fail'){
    el.classList.add('check-fail');
    el.textContent = 'FAIL';
  }else{
    el.classList.add('check-na');
    el.textContent = 'N/A';
  }
}

function parseBadgeFromText(text){
  try{
    return JSON.parse(text);
  }catch(e){}
  const m = text.match(/data-trace="([^"]+)"/i);
  if(m){
    try{
      const raw = decodeURIComponent(escape(atob(m[1])));
      return JSON.parse(raw);
    }catch(e){}
  }
  const m2 = text.match(/<metadata>([^<]+)<\/metadata>/i);
  if(m2){
    try{
      const raw = decodeURIComponent(escape(atob(m2[1])));
      return JSON.parse(raw);
    }catch(e){}
  }
  return null;
}
async function fileToHash(file){
  if(!file) return null;
  const buf = await file.arrayBuffer();
  return await sha256HexBuffer(buf);
}

async function verifyToken(token, maybeImageFile){
  resetChecks();

  if(!token || !token.proof || !token.proof.sig){
    vSetVisual('INVALID BADGE ‚ùå','Badge is missing proof data.','bad');
    return;
  }

  const core = {...token};
  delete core.proof;
  const msg = enc.encode(canonicalJSONString(core));

  let sigOK = false;
  try{
    sigOK = await verifyBytesEd25519(msg, token.proof.sig, token.proof.edPublic);
  }catch(e){
    console.error(e);
    sigOK = false;
  }

  let expired = false;
  try{
    const issued = Date.parse(token.metadata?.session?.issued_at || token.created_at || 0);
    const expMs  = (token.metadata?.session?.expires_in ?? 0)*1000;
    if(!isNaN(issued) && expMs>0){
      expired = (Date.now() > (issued+expMs));
    }
  }catch(e){
    expired = false;
  }

  const tn = getTraceNet();
  const cid = token.metadata?.creator_id;
  let creatorOK = false;
  let mindOK = false;
  if(cid && tn[cid]){
    creatorOK = true;
    const storedMind = tn[cid].mind;
    const tokenMind  = token.metadata?.mindprint?.mind_hash;
    if(storedMind && tokenMind && storedMind === tokenMind){
      mindOK = true;
    }
  }

  let imgOK = true;
  if(token.metadata?.image_hash){
    if(maybeImageFile){
      const upHash = await fileToHash(maybeImageFile);
      imgOK = (!!upHash && upHash === token.metadata.image_hash);
    } else {
      imgOK = true;
    }
  }

  if(expired){
    vSetVisual('EXPIRED ‚è≥','Badge was valid, but the 60s window has passed.','expired');
  }else if(!sigOK){
    vSetVisual('VERIFICATION FAILED ‚ùå','Signature does not match public key (invalid badge).','bad');
  }

  const checks = {
    signatur: sigOK,
    tid: !expired,
    creator: creatorOK,
    mindprint: mindOK,
    bild: imgOK
  };
  const passed = Object.values(checks).filter(Boolean).length;

  let statusForLog = 'failed';
  if(expired) statusForLog = 'expired';
  if(sigOK && !expired && passed >= 4) statusForLog = 'verified';

  if(sigOK && !expired && passed >= 4){
    let summary = 'Signature OK, time within window.';
    if(creatorOK) summary += ' TraceNet identity found.';
    if(mindOK)    summary += ' Mindprint matches.';
    if(token.metadata?.image_hash && !maybeImageFile){
      summary += ' Image not verified now, but other signals are strong.';
    } else if(token.metadata?.image_hash && imgOK){
      summary += ' Image hash matches.';
    }
    vSetVisual('HUMAN VERIFIED ‚úÖ', summary, 'ok');
  }else if(!expired && sigOK){
    vSetVisual('VERIFICATION FAILED ‚ùå','Too few signals match (need at least 4/5).','bad');
  }

  if(v_checks_panel){
    v_checks_panel.classList.remove('hide');
  }
  setCheck(chk_sign,    sigOK ? 'ok' : 'fail');
  setCheck(chk_time,    !expired ? 'ok' : 'fail');
  setCheck(chk_creator, creatorOK ? 'ok' : 'fail');
  setCheck(chk_mind,    cid ? (mindOK ? 'ok' : 'fail') : 'na');
  setCheck(chk_img,     token.metadata?.image_hash ? (imgOK ? 'ok' : 'fail') : 'na');

  if(chk_summary){
    chk_summary.textContent =
      `Signal-score: ${passed}/5. `+
      (passed>=4
        ? 'Enough signals satisfied to treat the badge as human-verified.'
        : 'Too few signals satisfied to verify this badge as human.');
  }

  // update verification log for dashboard
  verificationLog.unshift({
    time: new Date().toISOString(),
    status: statusForLog,
    creatorId: cid || '(none)',
    origin: token.metadata?.content_origin?.label || 'n/a'
  });
  if(verificationLog.length > 5) verificationLog = verificationLog.slice(0,5);
  renderVerificationLog();
}

async function smartVerify(){
  const badgeFile = v_file && v_file.files ? v_file.files[0] : null;
  const imgFile   = v_img && v_img.files ? (v_img.files[0] || null) : null;
  if(!badgeFile){
    alert('Upload a TRACE badge (.svg) first.');
    return;
  }
  const text = await badgeFile.text();
  const token = parseBadgeFromText(text);
  if(!token){
    alert('Could not read badge data.');
    return;
  }
  await verifyToken(token, imgFile);
}
async function quickVerifyCurrent(){
  const imgFile = v_img && v_img.files ? (v_img.files[0] || null) : null;
  if(!lastToken){
    vSetVisual('NO BADGE YET','Create a TRACE badge first in Step 3.','bad');
    resetChecks();
    return;
  }
  await verifyToken(lastToken, imgFile);
}

/* INIT */
ensureTraceNetRegistered();
renderTraceNetStatus();
updateKeyDisplay();
loadVault();
resetChecks();
renderCreatorDashboard()
async function testBackend() {
  const form = new FormData();
  form.append("image", new Blob(["test"], { type: "text/plain" }), "test.txt");

  const res = await fetch("https://signai-tamy.onrender.com/detect-image", {
    method: "POST",
    body: form
  });

  const data = await res.json();
  console.log("BACKEND TEST:", data);
}
;
window.testBackend = async function testBackend() {
  const form = new FormData();
  form.append("image", new Blob(["test"], { type: "text/plain" }), "test.txt");

  const res = await fetch("https://signai-tamy.onrender.com/detect-image", {
    method: "POST",
    body: form
  });

  const data = await res.json();
  console.log("BACKEND TEST:", data);
};
</script>
</body>
</html>
